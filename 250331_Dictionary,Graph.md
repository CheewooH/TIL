# 자료구조를 활용한 데이터 관리
## 해시테이블 (HashTable)
키 값을 해시함수로 해싱하여 해시테이블의 특정 위치로 직접 엑세스하도록 만든 방식  
해시 : 임의의 길이를 가진 데이터를 고정된 길이를 가진 데이터로 매핑
### <해시테이블 구현>
데이터를 담을 테이블을 이미 크게 확보해 놓은 후
입력받은 키를 해싱하여 테이블 고유한 index를 계산하고 데이터를 담아 보관
```cs
//           해싱
//          ┌────┐
//      2 ─→│    │─→   2
//    998 ─→│해시│─→ 998
//   2066 ─→│함수│─→  66
//   8027 ─→│    │─→  27
//          └────┘
//
//   [0]   [1]   [2]        [27]        [66]       [997] [998] [999]
// ┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
// │     │     │  2  │....│ 8027 │....│ 2066 │....│     │ 998 │     │
// └─────┴─────┴─────┴─  ─┴──────┴─  ─┴──────┴─  ─┴─────┴─────┴─────┘
```
### <해시함수>
키값을 해싱하여 고유한 index를 만드는 함수  
조건으로 하나의 키값을 해싱하는 경우 반드시 항상 같은 index를 반환해야 함  
대표적인 해시함수로 나눗셈법이 있음  
예시 : 2581 → (2581 % 1000) = 581

```cs
// <해시테이블 주의점 - 충돌>
// 해시함수가 서로 다른 입력 값에 대해 동일한 해시테이블 주소를 반환하는 것
// 모든 입력 값에 대해 고유한 해시 값을 만드는 것은 불가능하며 충돌은 피할 수 없음
//
//           해싱
//          ┌────┐
//   1081 ─→│해시│─→  81
//   2081 ─→│함수│─→  81
//          └────┘
//
//   [0]   [1]   [2]          [81]          [997] [998] [999]
// ┌─────┬─────┬─────┬─  ─┬───────────┬─  ─┬─────┬─────┬─────┐
// │     │     │     │....│ 1081 2081 │....│     │     │     │
// └─────┴─────┴─────┴─  ─┴───────────┴─  ─┴─────┴─────┴─────┘
//                          ↑충돌발생
```
### <충돌해결방안 - 체이닝>
해시 충돌이 발생하면 연결리스트로 데이터들을 연결하는 방식  
장점 : 해시테이블에 자료사용률에 따른 성능저하가 적음  
단점 : 해시테이블 외 추가적인 저장공간이 필요, 삽입삭제시 오버헤드가 발생  
```cs
//   [0]   [1]   [2]        [81]      [997] [998] [999]
// ┌─────┬─────┬─────┬─  ─┬──────┬─  ─┬─────┬─────┬─────┐
// │     │     │     │....│  │   │....│     │     │     │
// └─────┴─────┴─────┴─  ─┴──│───┴─  ─┴─────┴─────┴─────┘
//                           ↓
//                        ┌──────┬─┐ ┌──────┬─┐
//                        │ 1081 │──→│ 2081 │ │
//                        └──────┴─┘ └──────┴─┘
```
### <충돌해결방안 - 개방주소법>
해시 충돌이 발생하면 다른 빈 공간에 데이터를 삽입하는 방식
해시 충돌시 선형탐색, 제곱탐색, 이중해시 등을 통해 다른 빈 공간을 선정
장점 : 추가적인 저장공간이 필요하지 않음, 삽입삭제시 오버헤드가 적음
단점 : 해시테이블에 자료사용률에 따른 성능저하가 발생
```cs
//   [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
// ┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
// │     │     │     │....│ 1081 │      │....│     │     │     │
// └─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
//                          ↑2081(충돌)
//
//   [0]   [1]   [2]        [81]   [82]       [997] [998] [999]
// ┌─────┬─────┬─────┬─  ─┬──────┬──────┬─  ─┬─────┬─────┬─────┐
// │     │     │     │....│ 1081 │ 2081 │....│     │     │     │
// └─────┴─────┴─────┴─  ─┴──────┴──────┴─  ─┴─────┴─────┴─────┘
//                                 ↑(다음위치에 저장)
```
### <해시테이블 효율>
해시테이블의 공간 사용률이 높을 경우(통계적으로 70% 이상) 급격한 성능저하가 발생  
이런 경우 재해싱을 통해 공간 사용률을 낮추어 다시 효율을 확보함  
재해싱 : 해시테이블의 크기를 늘리고 테이블 내의 모든 데이터를 다시 해싱하여 보관  
```cs
// ┌─────┬─────┬─────┬─────┬─────┐
// │ 124 │ 258 │     │ 857 │ 858 │
// └─────┴─────┴─────┴─────┴─────┘
//   ↓ 재해싱
// ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
// │ 124 │     │     │ 857 │ 858 │     │     │ 258 │     │     │
// └─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
```
### <해시테이블 시간복잡도>
접근 : X 탐색 : O(1) 삽입 : O(1) 삭제 : O(1)

## Dictionary

```cs
public void MyDictionary()
{
    Dictionary<string, Monster> monsterDic = new Dictionary<string, Monster>();

    // 추가 : O(1)
    monsterDic.Add("피카츄", new Monster("피카츄", 1)); // monsterDic.Add("찾기위한 키값", new Monster(넣을 내용))
    monsterDic.Add("파이리 ", new Monster("파이리", 2));
    monsterDic.Add("꼬부기", new Monster("꼬부기", 3));
    monsterDic.Add("이상해씨", new Monster("이생해씨", 4));

    // 똑같은 키값을 두번사용하는건 불가하다
    // monsterDic.Add("피카츄", new Monster("피카츄", 1)); // error : 동일한 키의 데이터를 중복불가

    // monsterDic.TryAdd("피카츄");

    // if (monsterDic.ContainsKey("피카츄"))
    // {
    // monsterDic.Add("피카츄");
    // }

    // 삭제 : O(1)
    monsterDic.Remove("이상해씨");

    // 탐색 : O(1)
    monsterDic.ContainsKey("파이리");                       // ContainsKey : 있는지 없는지
    monsterDic.TryGetValue("파이리", out Monster monster);  // TryGetValue : 찾아서 있으면 주고 없으면 나오지마 (true, false로 반환)


    // 인덱서를 통한 간략한 사용
    Monster find = monsterDic["파이리"];
    monsterDic["피카츄"] = new Monster("피카츄", 1); // 대신 없으면 오류남 확실할 때에만 사용
}
```

## 그래프 (Graph)
정점의 모음과 이 정점을 잇는 간선의 모음의 결합
한 노드에서 출발하여 다시 자기 자신의 노드로 돌아오는 순환구조를 가짐
간선의 방향성에 따라 단방향 그래프, 양방향 그래프가 있음
간선의 가중치에 따라   연결 그래프, 가중치 그래프가 있음

### <인접행렬 그래프>
그래프 내의 각 정점의 인접 관계를 나타내는 행렬  
2차원 배열을 [출발정점, 도착정점] 으로 표현  
장점 : 인접여부 접근이 빠름  
단점 : 메모리 사용량이 많음  
```cs
// 예시 - 양방향 연결 그래프
bool[,] matrixGraph1 = new bool[5, 5]
{
{ false, false,  true, false,  true },
{ false, false,  true, false, false },
{  true,  true, false,  true, false },
{ false, false,  true, false,  true },
{  true, false, false,  true, false },
};

const int INF = int.MaxValue;

// 예시 - 단방향 가중치 그래프 (단절은 최대값으로 표현)
int[,] matrixGraph2 = new int[5, 5]
{
{   0, 132, INF, INF,  16 },
{  12,   0, INF, INF, INF },
{ INF,  38,   0, INF, INF },
{ INF,  12, INF,   0,  54 },
{ INF, INF, INF, INF,   0 },
};

// [0, 2] => 출발정점(0) -> 도착정점(2)
int distance = matrixGraph2[0, 2];  // 0에서 2까지 가중치
matrixGraph2[0, 2] = 10;            // 가중치 변경
```
### <인접리스트 그래프>
그래프 내의 각 정점의 인접 관계를 표현하는 리스트  
인접한 간선만을 리스트에 추가하여 관리  
장점 : 메모리 사용량이 적음  
단점 : 인접여부를 확인하기 위해 리스트 탐색이 필요

```cs
List<int>[] listGraph = new List<int>[5];
listGraph[0] = new List<int>(){2, 4};  // 0이 2와 4를 가지고있다 = 2와 4에 갈수있다
```
