# 디자인 패턴 응용

## Adapter Pattern
서로 호환되지 않는 인터페이스를 가진 클래스들이 함께 작동할 수 있도록 중간에 인터페이스를 변환해주는 역할
### 장점
- 기존 코드를 수정하지 않기 때문에 해당 코드가 변경 불가능하거나 업데이트 될 때에도 대응할 수 있다.
- 최소한의 변경으로 기존 코드를 재사용 할 수 있다

### 단점
- 약간의 성능 저하가 발생한다 (물론, 이슈가 되지 않을 만큼 미비한 성능 저하이다)
- 어댑터가 많아지면 복잡도 증가

### 언제 사용하면 좋을까
- 기존 코드가 변경 불가능하거나, 업데이트를 통해 기존 코드의 내용 변경이 우려될 때
- 레거시 코드임에도 해당 코드를 사용하는것이 효율적일 때
- 인터페이스 변경 없이 기능 확장이 필요할 때
  
## Singleton Pattern
싱글톤 패턴은 단 하나의 인스턴스만 생성되도록 보장하고, 전역적으로 접근 가능한 접근 지점을 제공하는 디자인 패턴  
특히 게임 개발에서 매니저 클래스(예: 게임 상태, 사운드, 씬 관리 등)에 자주 사용된다  

### 구현
1. 생성자의 접근 권한을 private 또는 protected로 제한하여 외부에서 인스턴스를 생성하지 못하게 함
2. 외부에서 인스턴스를 얻을 수 있도록 정적 메서드(GetInstance) 제공
3. 외부에서 접근이 가능한 GetInstance 함수를 구성
4. GetInstance에서 인스턴스가 없으면 생성하고 있으면 기존 인스턴스를 반환
5. 필요 시 멀티스레드 환경에서도 안전하게 동작하도록 동기화 처리

### 장점
1. **하나뿐인 존재로 주요 클래스 & 관리자 역할에 적합함**  
(단일 인스턴스로 전체 시스템에서 일관된 상태 유지)
1. 전역적 접근으로 참조에 필요한 작업이 없이 빠른 접근이 가능함
2. 인스턴스들이 싱글톤을 통하여 데이터를 공유하기 쉬워짐

### 단점
1. 싱글톤은 너무 많은 책임을 짊어지는 경우가 많으며 단일책임원칙을 위반
2. **싱글톤은 전역접근으로 코드의 결합도를 높이므로 남발하지 않아야함**
3. 싱글톤은 단위 테스트를 하기 어렵게 함

## Observer Pattern
옵저버 패턴은 **특정 객체(Subject)**의 상태가 변경되었을 때, **그에 의존하는 객체들(Observer)**에게 자동으로 알림을 보내는 디자인 패턴  
이 패턴은 데이터 변경을 실시간으로 감지할 수 있기 때문에, 주기적으로 상태를 확인하지 않아도 되어 게임 성능 최적화에도 유리  

### Subject
1. 상태를 가지고 있는 주체이며, 여러 옵저버를 등록/관리함
2. 내부 상태가 변경되면 모든 등록된 옵저버들에게 알림을 전달
3. Attach, Detach, Notify 등의 메서드를 가짐

### Observer
1. Subject를 관찰하는 관찰자 객체
2. Subject로부터 알림을 받으면 자신의 동작을 수행
3. 일반적으로 Update()와 같은 콜백 메서드를 구현

### 옵저버 패턴 사용시의 주의점
옵저버 패턴은 **특정 객체(Subject)**의 상태가 변경되었을 때, **그에 의존하는 객체들(Observer)**에게 자동으로 알림을 보내는 디자인 패턴  
이 패턴은 데이터 변경을 실시간으로 감지할 수 있기 때문에, 주기적으로 상태를 확인하지 않아도 되어 게임 성능 최적화에도 유리  

1. 사용하지 않는 옵저버는 반드시 구독 해지할 것
* 옵저버는 Subject에 등록된 상태로 계속 남아있기 때문에,
더 이상 사용되지 않는 옵저버는 명시적으로 구독 해지 (Detach) 해야 함
* 해지하지 않으면 메모리 누수나 의도치 않은 동작이 발생할 수 있음

2. 옵저버 수가 많아지면 성능에 영향
* 상태 변경 시 모든 옵저버에게 알림을 보내기 때문에
구독자 수가 많아질수록 성능이 저하될 수 있음
* 최적화를 위해 조건부 알림, 필터링 등의 추가 전략을 고려할 수 있음
3. 구조 복잡도 증가
* 객체 간의 결합은 낮지만 관계가 암묵적으로 연결되기 때문에 디버깅이나 구조 파악이 어려워질 수 있음
* 이를 방지하기 위해 명확한 설계 문서와 네이밍 컨벤션이 중요함
### 언제 사용하면 좋을까?
* 하나의 상태 변화에 여러 객체가 반응해야 할 때
* 실시간 반응성이 중요한 시스템 (예: UI, 이벤트 시스템, 상태 기반 트리거 등)
* 게임 내에서 모든 유닛이 특정 상황에 반응해야 할 때 (예: 플레이어 사망, 특정 오브젝트 파괴 등)
